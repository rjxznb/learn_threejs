<!DOCTYPE>
<html>
<head>
    <meta charset="UTF-8">
    <title>Canvas Example</title>
</head>


<body>
    <script type='importmap'>
    {
        "imports": {
            "three": "./three/build/three.module.js",
            "three/addons/": "./three/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';


        const geometry = new THREE.BufferGeometry();
        // 创建一个简单的矩形. 在这里我们左上和右下顶点被复制了两次。
        // 因为在两个三角面片里，这两个顶点都需要被用到。
        const vertices = new Float32Array( [
            -1.0, -1.0,  1.0, // v0
            1.0, -1.0,  1.0, // v1
            1.0,  1.0,  1.0, // v2
            -1.0,  1.0,  1.0, // v3
        ] );

        // 每个顶点的法线数据和顶点位置数据一一对应
        const normals = new Float32Array([
            0, 0, 1, //顶点1, 6法线( 法向量 )
            0, 1, 0, //顶点2法线
            0, 1, 1, //顶点3, 4法线
            0, 0, 1, //顶点6法线
        ]);

        // 顶点索引
        const index = [
            0, 1, 2,
            2, 3, 0,
        ];

        
        // geometry.index = new THREE.BufferAttribute(index, 1); // itemSize = 1 因为每个索引是一个单独的整数；
        geometry.setIndex(index); // or geometry.index = new THREE.BufferAttribute(indexes, 1); itemSize = 1 因为每个索引是一个单独的整数；
        geometry.attributes.position = new THREE.BufferAttribute(vertices, 3); // itemSize = 3 因为每个顶点都是一个三元组。
        geometry.attributes.normal = new THREE.BufferAttribute(normals, 3); // itemSize = 3 因为每个法线都是一个三元组。
        console.log(geometry.attributes);

        const material = new THREE.MeshLambertMaterial( { color: 0xff0000, side:THREE.DoubleSide, wireframe:true } );
        const mesh = new THREE.Mesh( geometry, material, 4, 1);


        const scene = new THREE.Scene();
        scene.add(mesh);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        camera.lookAt(mesh.position);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.decay = 0;
        light.position.set(1, 1, 1).normalize();
        scene.add(light);
        


        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        function animate() {
            requestAnimationFrame(animate);
            mesh.rotation.x += 0.01;
            //points.rotation.y += 0.01;
            renderer.render(scene, camera);
        }
        animate();



    </script>


</body>
</html>